using System;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.ReverseEngineering;
using YoutubeExplode.ReverseEngineering.Responses;

namespace YoutubeExplode.Videos.ClosedCaptions
{
    public class ClosedCaptionTrackClient
    {
        private readonly HttpClient _httpClient;

        public ClosedCaptionTrackClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        public async Task<ClosedCaptionTrackManifest> GetManifestAsync(VideoId videoId)
        {
            var videoInfoResponse = await VideoInfoResponse.GetAsync(_httpClient, videoId);
            var playerResponse = videoInfoResponse.GetPlayerResponse();

            var tracks = playerResponse
                .GetClosedCaptionTracks()
                .Select(track => new ClosedCaptionTrackInfo(
                    track.GetUrl(),
                    new Language(
                        track.GetLanguageCode(),
                        track.GetLanguageName()
                    ),
                    track.IsAutoGenerated()
                )).ToArray();

            return new ClosedCaptionTrackManifest(tracks);
        }

        public async Task<ClosedCaptionTrack> GetAsync(ClosedCaptionTrackInfo trackInfo)
        {
            var response = await ClosedCaptionTrackResponse.GetAsync(_httpClient, trackInfo.Url);

            var captions = response.GetClosedCaptions()
                .Where(t => !string.IsNullOrWhiteSpace(t.GetText()))
                .Select(t => new ClosedCaption(
                    t.GetText(),
                    t.GetOffset(),
                    t.GetDuration()
                )).ToArray();

            return new ClosedCaptionTrack(captions);
        }

        public async Task WriteToAsync(ClosedCaptionTrackInfo trackInfo, TextWriter writer,
            IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            var track = await GetAsync(trackInfo);

            var buffer = new StringBuilder();
            for (var i = 0; i < track.ClosedCaptions.Count; i++)
            {
                var caption = track.ClosedCaptions[i];
                buffer.Clear();

                cancellationToken.ThrowIfCancellationRequested();

                // Line number
                buffer.AppendLine((i + 1).ToString());

                // Time start --> time end
                buffer.Append(caption.Offset.ToString(@"hh\:mm\:ss\,fff"));
                buffer.Append(" --> ");
                buffer.Append((caption.Offset + caption.Duration).ToString(@"hh\:mm\:ss\,fff"));
                buffer.AppendLine();

                // Actual text
                buffer.AppendLine(caption.Text);

                await writer.WriteLineAsync(buffer.ToString());
                progress?.Report((i + 1.0) / track.ClosedCaptions.Count);
            }
        }

        public async Task DownloadAsync(ClosedCaptionTrackInfo trackInfo, string filePath,
            IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            using var writer = File.CreateText(filePath);
            await WriteToAsync(trackInfo, writer, progress, cancellationToken);
        }
    }
}