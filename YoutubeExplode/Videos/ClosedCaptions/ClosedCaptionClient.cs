using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Bridge;
using YoutubeExplode.Exceptions;

namespace YoutubeExplode.Videos.ClosedCaptions
{
    /// <summary>
    /// Queries related to closed captions of YouTube videos.
    /// </summary>
    public class ClosedCaptionClient
    {
        private readonly YoutubeController _controller;

        /// <summary>
        /// Initializes an instance of <see cref="ClosedCaptionClient"/>.
        /// </summary>
        public ClosedCaptionClient(HttpClient httpClient)
        {
            _controller = new YoutubeController(httpClient);
        }

        /// <summary>
        /// Gets the manifest that contains information about available closed caption tracks in the specified video.
        /// </summary>
        public async ValueTask<ClosedCaptionManifest> GetManifestAsync(
            VideoId videoId,
            CancellationToken cancellationToken = default)
        {
            var videoInfo = await _controller.GetVideoInfoAsync(videoId, cancellationToken);

            var playerResponse =
                videoInfo.TryGetPlayerResponse() ??
                throw new YoutubeExplodeException("Could not extract player response.");

            var trackInfos = new List<ClosedCaptionTrackInfo>();

            foreach (var trackInfoExtractor in playerResponse.GetClosedCaptionTracks())
            {
                var url =
                    trackInfoExtractor.TryGetUrl() ??
                    throw new YoutubeExplodeException("Could not extract track URL.");

                var languageCode =
                    trackInfoExtractor.TryGetLanguageCode() ??
                    throw new YoutubeExplodeException("Could not extract track language code.");

                var languageName =
                    trackInfoExtractor.TryGetLanguageName() ??
                    throw new YoutubeExplodeException("Could not extract track language name.");

                var language = new Language(languageCode, languageName);

                var isAutoGenerated = trackInfoExtractor.IsAutoGenerated();

                var track = new ClosedCaptionTrackInfo(url, language, isAutoGenerated);
                trackInfos.Add(track);
            }

            return new ClosedCaptionManifest(trackInfos);
        }

        /// <summary>
        /// Gets the actual closed caption track which is identified by the specified metadata.
        /// </summary>
        public async ValueTask<ClosedCaptionTrack> GetAsync(
            ClosedCaptionTrackInfo trackInfo,
            CancellationToken cancellationToken = default)
        {
            var trackExtractor = await _controller.GetClosedCaptionTrackAsync(trackInfo.Url, cancellationToken);

            var captions = new List<ClosedCaption>();

            foreach (var captionExtractor in trackExtractor.GetClosedCaptions())
            {
                var text = captionExtractor.TryGetText();
                if (string.IsNullOrWhiteSpace(text))
                    continue;

                var offset =
                    captionExtractor.TryGetOffset() ??
                    throw new YoutubeExplodeException("Could not extract caption offset.");

                var duration =
                    captionExtractor.TryGetDuration() ??
                    throw new YoutubeExplodeException("Could not extract caption duration.");

                var parts = new List<ClosedCaptionPart>();

                foreach (var partExtractor in captionExtractor.GetParts())
                {
                    var partText = partExtractor.TryGetText();
                    if (string.IsNullOrWhiteSpace(partText))
                        continue;

                    var partOffset =
                        partExtractor.TryGetOffset() ??
                        throw new YoutubeExplodeException("Could not extract caption part offset.");

                    var part = new ClosedCaptionPart(partText, partOffset);
                    parts.Add(part);
                }

                var caption = new ClosedCaption(text, offset, duration, parts);
                captions.Add(caption);
            }

            return new ClosedCaptionTrack(captions);
        }

        /// <summary>
        /// Writes the actual closed caption track which is identified by the specified metadata to the destination writer.
        /// Closed captions are written in the SRT file format.
        /// </summary>
        public async ValueTask WriteToAsync(
            ClosedCaptionTrackInfo trackInfo,
            TextWriter writer,
            IProgress<double>? progress = null,
            CancellationToken cancellationToken = default)
        {
            var track = await GetAsync(trackInfo, cancellationToken);

            var buffer = new StringBuilder();
            for (var i = 0; i < track.Captions.Count; i++)
            {
                var caption = track.Captions[i];
                buffer.Clear();

                cancellationToken.ThrowIfCancellationRequested();

                // Line number
                buffer.AppendLine((i + 1).ToString());

                // Time start --> time end
                buffer.Append(caption.Offset.ToString(@"hh\:mm\:ss\,fff"));
                buffer.Append(" --> ");
                buffer.Append((caption.Offset + caption.Duration).ToString(@"hh\:mm\:ss\,fff"));
                buffer.AppendLine();

                // Actual text
                buffer.AppendLine(caption.Text);

                await writer.WriteLineAsync(buffer.ToString());
                progress?.Report((i + 1.0) / track.Captions.Count);
            }
        }

        /// <summary>
        /// Downloads the actual closed caption track which is identified by the specified metadata to the destination file.
        /// Closed captions are written in the SRT file format.
        /// </summary>
        public async ValueTask DownloadAsync(
            ClosedCaptionTrackInfo trackInfo,
            string filePath,
            IProgress<double>? progress = null,
            CancellationToken cancellationToken = default)
        {
            using var writer = File.CreateText(filePath);
            await WriteToAsync(trackInfo, writer, progress, cancellationToken);
        }
    }
}