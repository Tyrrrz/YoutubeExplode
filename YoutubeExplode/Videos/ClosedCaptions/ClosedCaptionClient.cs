using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using YoutubeExplode.Exceptions;
using YoutubeExplode.Extraction;

namespace YoutubeExplode.Videos.ClosedCaptions
{
    /// <summary>
    /// Queries related to closed captions of YouTube videos.
    /// </summary>
    public class ClosedCaptionClient
    {
        private readonly YoutubeController _youtubeController;

        /// <summary>
        /// Initializes an instance of <see cref="ClosedCaptionClient"/>.
        /// </summary>
        public ClosedCaptionClient(HttpClient httpClient)
        {
            _youtubeController = new YoutubeController(httpClient);
        }

        /// <summary>
        /// Gets the manifest that contains information about available closed caption tracks in the specified video.
        /// </summary>
        public async ValueTask<ClosedCaptionManifest> GetManifestAsync(
            VideoId videoId,
            CancellationToken cancellationToken = default)
        {
            var videoInfoResponse = await _youtubeController.GetVideoInfoResponseAsync(videoId, cancellationToken);

            var playerResponse =
                videoInfoResponse.TryGetPlayerResponse() ??
                throw new YoutubeExplodeException("Could not extract player response.");

            var tracks = new List<ClosedCaptionTrackInfo>();

            foreach (var trackResponse in playerResponse.GetClosedCaptionTracks())
            {
                var url =
                    trackResponse.TryGetUrl() ??
                    throw new YoutubeExplodeException("Could not extract track URL.");

                var languageCode =
                    trackResponse.TryGetLanguageCode() ??
                    throw new YoutubeExplodeException("Could not extract track language code.");

                var languageName =
                    trackResponse.TryGetLanguageName() ??
                    throw new YoutubeExplodeException("Could not extract track language name.");

                var language = new Language(languageCode, languageName);

                var isAutoGenerated = trackResponse.IsAutoGenerated();

                var track = new ClosedCaptionTrackInfo(
                    url,
                    language,
                    isAutoGenerated
                );

                tracks.Add(track);
            }

            return new ClosedCaptionManifest(tracks);
        }

        /// <summary>
        /// Gets the actual closed caption track which is identified by the specified metadata.
        /// </summary>
        public async ValueTask<ClosedCaptionTrack> GetAsync(
            ClosedCaptionTrackInfo trackInfo,
            CancellationToken cancellationToken = default)
        {
            var trackResponse = await _youtubeController.GetClosedCaptionTrackResponseAsync(
                trackInfo.Url,
                cancellationToken
            );

            var captions = new List<ClosedCaption>();

            foreach (var captionResponse in trackResponse.GetClosedCaptions())
            {
                var text = captionResponse.TryGetText();
                if (string.IsNullOrWhiteSpace(text))
                    continue;

                var offset =
                    captionResponse.TryGetOffset() ??
                    throw new YoutubeExplodeException("Could not extract caption offset.");

                var duration =
                    captionResponse.TryGetDuration() ??
                    throw new YoutubeExplodeException("Could not extract caption duration.");

                var parts = new List<ClosedCaptionPart>();

                foreach (var partResponse in captionResponse.GetParts())
                {
                    var partText = partResponse.TryGetText();
                    if (string.IsNullOrWhiteSpace(partText))
                        continue;

                    var partOffset =
                        partResponse.TryGetOffset() ??
                        throw new YoutubeExplodeException("Could not extract caption part offset.");

                    var part = new ClosedCaptionPart(partText, partOffset);

                    parts.Add(part);
                }

                var caption = new ClosedCaption(
                    text,
                    offset,
                    duration,
                    parts
                );

                captions.Add(caption);
            }

            return new ClosedCaptionTrack(captions);
        }

        /// <summary>
        /// Writes the actual closed caption track which is identified by the specified metadata to the destination writer.
        /// Closed captions are written in the SRT file format.
        /// </summary>
        public async ValueTask WriteToAsync(
            ClosedCaptionTrackInfo trackInfo,
            TextWriter writer,
            IProgress<double>? progress = null,
            CancellationToken cancellationToken = default)
        {
            var track = await GetAsync(trackInfo, cancellationToken);

            var buffer = new StringBuilder();
            for (var i = 0; i < track.Captions.Count; i++)
            {
                var caption = track.Captions[i];
                buffer.Clear();

                cancellationToken.ThrowIfCancellationRequested();

                // Line number
                buffer.AppendLine((i + 1).ToString());

                // Time start --> time end
                buffer.Append(caption.Offset.ToString(@"hh\:mm\:ss\,fff"));
                buffer.Append(" --> ");
                buffer.Append((caption.Offset + caption.Duration).ToString(@"hh\:mm\:ss\,fff"));
                buffer.AppendLine();

                // Actual text
                buffer.AppendLine(caption.Text);

                await writer.WriteLineAsync(buffer.ToString());
                progress?.Report((i + 1.0) / track.Captions.Count);
            }
        }

        /// <summary>
        /// Downloads the actual closed caption track which is identified by the specified metadata to the destination file.
        /// Closed captions are written in the SRT file format.
        /// </summary>
        public async ValueTask DownloadAsync(
            ClosedCaptionTrackInfo trackInfo,
            string filePath,
            IProgress<double>? progress = null,
            CancellationToken cancellationToken = default)
        {
            using var writer = File.CreateText(filePath);
            await WriteToAsync(trackInfo, writer, progress, cancellationToken);
        }
    }
}